#include "main.hpp"

const uint32_t glMajor = 4;
const uint32_t glMinor = 5;

int main() {
  Window mainWindow;
  mainWindow->run();


  // Main Event Loop
  while (!glfwWindowShouldClose(window)) {
    glfwPollEvents();

    // Render
    glClearColor(0.07f, 0.09f, 0.34f, 0.01f);
    glClear(GL_COLOR_BUFFER_BIT);

   

    glfwSwapBuffers(window);
  }

  /*
    // Setup Dear ImGui context
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO &io = ImGui::GetIO();
    (void)io;
    // io.ConfigFlags |=
    //     ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls
    // io.ConfigFlags |=
    //     ImGuiConfigFlags_NavEnableGamepad; // Enable Gamepad Controls
    // TO-DO: add a way to control things with mouse too
    // io.ConfigWindowsMoveFromTitleBarOnly // check this

    // Setup Dear ImGui style to dark
    ImGui::StyleColorsDark();

    // Setup platform/renderer backends
    ImGui_ImplGlfw_InitForOpenGL(window, true); // platform: GLFW
    ImGui_ImplOpenGL3_Init(glslVersion);        // renderer: OpenGL

    // ImVec4: 4D vector used to store clipping rectangles, colors etc.
    ImVec4 clearColor = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);
    int displayWidth, displayHeight;

    // Array of items to diplay on main menu
    const std::string menuItems[] = {"Show me magic!", "Help", "About"};
    std::string menuItemSelection;
    bool showNewWindow = false;

    while (!glfwWindowShouldClose(window)) {
      // Poll and handle events (inputs, window resize, etc.)
      // You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to
      // tell if dear imgui wants to use your inputs.
      // - When io.WantCaptureMouse is true, do not dispatch mouse input data to
      // your main application.
      // - When io.WantCaptureKeyboard is true, do not dispatch keyboard input
      // data to your main application. Generally you may always pass all inputs
      // to dear imgui, and hide them from your application based on those two
      // flags.
      glfwPollEvents();

      // Start the Dear ImGui frame
      ImGui_ImplOpenGL3_NewFrame();
      ImGui_ImplGlfw_NewFrame();
      ImGui::NewFrame();

      ImGui::Begin("Voxeloop");
      ImGui::Text("MAIN MENU");

      for (auto menuItem : menuItems) {
        if (ImGui::Button(menuItem.c_str())) {
          showNewWindow = true;
          menuItemSelection = menuItem;
        }
      }

      ImGui::End();

      if (showNewWindow) {
        ImGui::Begin(menuItemSelection.c_str(), &showNewWindow);
        // ImGui::Text("Hello!");
        glClearColor(0.1f, 0.3f, 0.2f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        ImGui::End();
      }

      // Rendering
      ImGui::Render();
      glfwGetFramebufferSize(window, &displayWidth, &displayHeight);
      glViewport(0, 0, displayWidth, displayHeight);
      glClearColor(clearColor.x * clearColor.w, clearColor.y * clearColor.w,
                   clearColor.z * clearColor.w, clearColor.w);
      glClear(GL_COLOR_BUFFER_BIT);
      ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

      glfwSwapBuffers(window);
    }
   */

  return EXIT_SUCCESS;
}

static void glfwErrorCallback(int error, const char *description) {
  fprintf(stderr, "GLFW Error %d: %s\n", error, description);
}

Window::Window(int windowWidth, int windowHeight, std::string title) {
  initGLAD();
  initGLFW(windowWidth, windowHeight, title);
  initDearImGui();
}

bool Window::initGLAD() {
  // load all OpenGL function pointers with glad
  if (!gladLoaderLoadGL()) {
    std::cerr << "[ERROR] Couldn't initialize GLAD" << std::endl;
    return false;
  } else
    std::cout << "[INFO] GLAD initialized" << std::endl;

  return true;
}

bool Window::initGLFW(int windowWidth, int windowHeight, std::string title) {
  // Initialize project along with error callback
  glfwSetErrorCallback(glfwErrorCallback);

  if (!glfwInit())
    return false;

  this->_glslVersion = "#version 130";
  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, glMajor);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, glMinor);
  glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

  // Setup Window
  this->_window = glfwCreateWindow(windowWidth, windowHeight, title.c_str(),
                                   nullptr, nullptr);
  if (!this->_window) {
    std::cout << "Couldn't open window" << std::endl;
    glfwTerminate();
    return EXIT_FAILURE;
  }
  glfwMakeContextCurrent(this->_window);
  glfwSwapInterval(1); // vsync

  return true;
}

bool Window::initDearImGui() {
  // Setup Dear ImGui context
  IMGUI_CHECKVERSION();
  ImGui::CreateContext();
  ImGuiIO &io = ImGui::GetIO();
  (void)io;
  // io.ConfigFlags |=
  //     ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls
  // io.ConfigFlags |=
  //     ImGuiConfigFlags_NavEnableGamepad; // Enable Gamepad Controls
  // TO-DO: add a way to control things with mouse too

  // Setup Dear ImGui style to dark
  ImGui::StyleColorsDark();

  // Setup platform/renderer backends
  ImGui_ImplGlfw_InitForOpenGL(this->_window, true); // platform: GLFW
  ImGui_ImplOpenGL3_Init(_glslVersion.c_str());      // renderer: OpenGL

  return true;
}

void Window::cleanup() {
  // ImGui cleanup
  ImGui_ImplOpenGL3_Shutdown();
  ImGui_ImplGlfw_Shutdown();
  ImGui::DestroyContext();

  // Destroy and terminate
  // Shader and Texture
  // vao.remove();
  // vbo.remove();
  // ebo.remove();
  // texture.remove();
  // shader.remove();

  // GLFW window cleanup
  glfwDestroyWindow(this->_window);
  glfwTerminate();
}

Window::~Window() { cleanup(); }